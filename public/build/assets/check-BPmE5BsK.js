import{ad as U,ae as k,r as v,c as I,B as P,af as W,ag as j,ah as Y,ai as J,C as _,k as Q,m as X,d as S,$ as D,u as N,x as Z,s as ee,p as q,o as L,q as M,f as te,A as C,R as B}from"./app-B7mv4fK4.js";import{r as ne,S as O,P as V,b as oe}from"./AppLogoIcon.vue_vue_type_script_setup_true_lang-BWbdOJM1.js";import{p as ae,i as re,u as G,b as ie}from"./useForwardExpose-CUaninMz.js";function K(t,e){const o=typeof t=="string"&&!e?`${t}Context`:e,n=Symbol(o);return[r=>{const c=U(n,r);if(c||c===null)return c;throw new Error(`Injection \`${n.toString()}\` not found. Component must be used within ${Array.isArray(t)?`one of the following components: ${t.join(", ")}`:`\`${t}\``}`)},r=>(k(n,r),r)]}function R(){let t=document.activeElement;if(t==null)return null;for(;t!=null&&t.shadowRoot!=null&&t.shadowRoot.activeElement!=null;)t=t.shadowRoot.activeElement;return t}const[se,Se]=K("ConfigProvider");function ue(t){const e=se({dir:v("ltr")});return I(()=>t?.value||e.dir?.value||"ltr")}function le(t){const e=P(),o=e?.type.emits,n={};return o?.length||console.warn(`No emitted event found. Please check component: ${e?.type.__name}`),o?.forEach(a=>{n[W(j(a))]=(...u)=>t(a,...u)}),n}function ce(t){const e=P(),o=Object.keys(e?.type.props??{}).reduce((a,u)=>{const r=(e?.type.props[u]).default;return r!==void 0&&(a[u]=r),a},{}),n=Y(t);return I(()=>{const a={},u=e?.vnode.props??{};return Object.keys(u).forEach(r=>{a[j(r)]=u[r]}),Object.keys({...o,...a}).reduce((r,c)=>(n.value[c]!==void 0&&(r[c]=n.value[c]),r),{})})}function Te(t,e){const o=ce(t),n=e?le(e):{};return I(()=>({...o.value,...n}))}function _e(t,e="reka"){return`${e}-${J?.()}`}function de(t,e){const o=v(t);function n(u){return e[o.value][u]??o.value}return{state:o,dispatch:u=>{o.value=n(u)}}}function fe(t,e){const o=v({}),n=v("none"),a=v(t),u=t.value?"mounted":"unmounted";let r;const c=e.value?.ownerDocument.defaultView??ae,{state:p,dispatch:d}=de(u,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),i=s=>{if(re){const l=new CustomEvent(s,{bubbles:!1,cancelable:!1});e.value?.dispatchEvent(l)}};_(t,async(s,l)=>{const g=l!==s;if(await Q(),g){const E=n.value,A=T(e.value);s?(d("MOUNT"),i("enter"),A==="none"&&i("after-enter")):A==="none"||A==="undefined"||o.value?.display==="none"?(d("UNMOUNT"),i("leave"),i("after-leave")):l&&E!==A?(d("ANIMATION_OUT"),i("leave")):(d("UNMOUNT"),i("after-leave"))}},{immediate:!0});const f=s=>{const l=T(e.value),g=l.includes(s.animationName),E=p.value==="mounted"?"enter":"leave";if(s.target===e.value&&g&&(i(`after-${E}`),d("ANIMATION_END"),!a.value)){const A=e.value.style.animationFillMode;e.value.style.animationFillMode="forwards",r=c?.setTimeout(()=>{e.value?.style.animationFillMode==="forwards"&&(e.value.style.animationFillMode=A)})}s.target===e.value&&l==="none"&&d("ANIMATION_END")},m=s=>{s.target===e.value&&(n.value=T(e.value))},h=_(e,(s,l)=>{s?(o.value=getComputedStyle(s),s.addEventListener("animationstart",m),s.addEventListener("animationcancel",f),s.addEventListener("animationend",f)):(d("ANIMATION_END"),r!==void 0&&c?.clearTimeout(r),l?.removeEventListener("animationstart",m),l?.removeEventListener("animationcancel",f),l?.removeEventListener("animationend",f))},{immediate:!0}),y=_(p,()=>{const s=T(e.value);n.value=p.value==="mounted"?s:"none"});return X(()=>{h(),y()}),{isPresent:I(()=>["mounted","unmountSuspended"].includes(p.value))}}function T(t){return t&&getComputedStyle(t).animationName||"none"}var Ne=S({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(t,{slots:e,expose:o}){const{present:n,forceMount:a}=D(t),u=v(),{isPresent:r}=fe(n,u);o({present:r});let c=e.default({present:r.value});c=ne(c||[]);const p=P();if(c&&c?.length>1){const d=p?.parent?.type.name?`<${p.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${d}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(i=>`  - ${i}`).join(`
`)].join(`
`))}return()=>a.value||n.value||r.value?N(e.default({present:r.value})[0],{ref:d=>{const i=G(d);return typeof i?.hasAttribute>"u"||(i?.hasAttribute("data-reka-popper-content-wrapper")?u.value=i.firstElementChild:u.value=i),i}}):null}});function x(){const t=v(),e=I(()=>["#text","#comment"].includes(t.value?.$el.nodeName)?t.value?.$el.nextElementSibling:G(t));return{primitiveElement:t,currentElement:e}}const $="data-reka-collection-item";function me(t={}){const{key:e="",isProvider:o=!1}=t,n=`${e}CollectionProvider`;let a;if(o){const i=v(new Map);a={collectionRef:v(),itemMap:i},k(n,a)}else a=U(n);const u=(i=!1)=>{const f=a.collectionRef.value;if(!f)return[];const m=Array.from(f.querySelectorAll(`[${$}]`)),y=Array.from(a.itemMap.value.values()).sort((w,s)=>m.indexOf(w.ref)-m.indexOf(s.ref));return i?y:y.filter(w=>w.ref.dataset.disabled!=="")},r=S({name:"CollectionSlot",setup(i,{slots:f}){const{primitiveElement:m,currentElement:h}=x();return _(h,()=>{a.collectionRef.value=h.value}),()=>N(O,{ref:m},f)}}),c=S({name:"CollectionItem",inheritAttrs:!1,props:{value:{validator:()=>!0}},setup(i,{slots:f,attrs:m}){const{primitiveElement:h,currentElement:y}=x();return Z(w=>{if(y.value){const s=ee(y.value);a.itemMap.value.set(s,{ref:y.value,value:i.value}),w(()=>a.itemMap.value.delete(s))}}),()=>N(O,{...m,[$]:"",ref:h},f)}}),p=I(()=>Array.from(a.itemMap.value.values())),d=I(()=>a.itemMap.value.size);return{getItems:u,reactiveItems:p,itemMapSize:d,CollectionSlot:r,CollectionItem:c}}const pe="rovingFocusGroup.onEntryFocus",ve={bubbles:!1,cancelable:!0},he={ArrowLeft:"prev",ArrowUp:"prev",ArrowRight:"next",ArrowDown:"next",PageUp:"first",Home:"first",PageDown:"last",End:"last"};function ye(t,e){return e!=="rtl"?t:t==="ArrowLeft"?"ArrowRight":t==="ArrowRight"?"ArrowLeft":t}function Me(t,e,o){const n=ye(t.key,o);if(!(e==="vertical"&&["ArrowLeft","ArrowRight"].includes(n))&&!(e==="horizontal"&&["ArrowUp","ArrowDown"].includes(n)))return he[n]}function ge(t,e=!1){const o=R();for(const n of t)if(n===o||(n.focus({preventScroll:e}),R()!==o))return}function Pe(t,e){return t.map((o,n)=>t[(e+n)%t.length])}const[Fe,Ae]=K("RovingFocusGroup");var Ee=S({__name:"RovingFocusGroup",props:{orientation:{type:String,required:!1,default:void 0},dir:{type:String,required:!1},loop:{type:Boolean,required:!1,default:!1},currentTabStopId:{type:[String,null],required:!1},defaultCurrentTabStopId:{type:String,required:!1},preventScrollOnEntryFocus:{type:Boolean,required:!1,default:!1},asChild:{type:Boolean,required:!1},as:{type:null,required:!1}},emits:["entryFocus","update:currentTabStopId"],setup(t,{expose:e,emit:o}){const n=t,a=o,{loop:u,orientation:r,dir:c}=D(n),p=ue(c),d=ie(n,"currentTabStopId",a,{defaultValue:n.defaultCurrentTabStopId,passive:n.currentTabStopId===void 0}),i=v(!1),f=v(!1),m=v(0),{getItems:h,CollectionSlot:y}=me({isProvider:!0});function w(l){const g=!f.value;if(l.currentTarget&&l.target===l.currentTarget&&g&&!i.value){const E=new CustomEvent(pe,ve);if(l.currentTarget.dispatchEvent(E),a("entryFocus",E),!E.defaultPrevented){const A=h().map(b=>b.ref).filter(b=>b.dataset.disabled!==""),F=A.find(b=>b.getAttribute("data-active")===""),H=A.find(b=>b.id===d.value),z=[F,H,...A].filter(Boolean);ge(z,n.preventScrollOnEntryFocus)}}f.value=!1}function s(){setTimeout(()=>{f.value=!1},1)}return e({getItems:h}),Ae({loop:u,dir:p,orientation:r,currentTabStopId:d,onItemFocus:l=>{d.value=l},onItemShiftTab:()=>{i.value=!0},onFocusableItemAdd:()=>{m.value++},onFocusableItemRemove:()=>{m.value--}}),(l,g)=>(L(),q(C(y),null,{default:M(()=>[te(C(V),{tabindex:i.value||m.value===0?-1:0,"data-orientation":C(r),as:l.as,"as-child":l.asChild,dir:C(p),style:{outline:"none"},onMousedown:g[0]||(g[0]=E=>f.value=!0),onMouseup:s,onFocus:w,onBlur:g[1]||(g[1]=E=>i.value=!1)},{default:M(()=>[B(l.$slots,"default")]),_:3},8,["tabindex","data-orientation","as","as-child","dir"])]),_:3}))}}),Oe=Ee,we=S({__name:"VisuallyHidden",props:{feature:{type:String,required:!1,default:"focusable"},asChild:{type:Boolean,required:!1},as:{type:null,required:!1,default:"span"}},setup(t){return(e,o)=>(L(),q(C(V),{as:e.as,"as-child":e.asChild,"aria-hidden":e.feature==="focusable"?"true":void 0,"data-hidden":e.feature==="fully-hidden"?"":void 0,tabindex:e.feature==="fully-hidden"?"-1":void 0,style:{position:"absolute",border:0,width:"1px",height:"1px",padding:0,margin:"-1px",overflow:"hidden",clip:"rect(0, 0, 0, 0)",clipPath:"inset(50%)",whiteSpace:"nowrap",wordWrap:"normal"}},{default:M(()=>[B(e.$slots,"default")]),_:3},8,["as","as-child","aria-hidden","data-hidden","tabindex"]))}}),Re=we;/**
 * @license lucide-vue-next v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const xe=oe("CheckIcon",[["path",{d:"M20 6 9 17l-5-5",key:"1gmf2c"}]]);export{xe as C,Ne as P,Oe as R,Re as V,me as a,x as b,K as c,Te as d,ce as e,ge as f,Me as g,se as h,Fe as i,R as j,le as k,ue as l,_e as u,Pe as w};
